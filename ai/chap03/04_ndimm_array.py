import numpy as np

# Vector(1차원 배열)
X = np.array([1,2,3,4,5])
print(X.shape) # (5,) 1차원의 배열 - 열 개수 카운팅 / ndarray


# 3x2 행렬과 2x3 행렬의 내적(Matrix: 2차원 배열)
A = np.array([[1,2],[3,4],[5,6]])
print(A.shape) # (3, 2) 3행 2열
B = np.array(([[1,2,3],[4,5,6]]))
print(B.shape) # (2, 3) 2행 3열

Z = np.dot(A,B)
print(Z)
"""
[[ 9 12 15] (1x1 + 2x4) (1x2 + 2x5) (1x3 + 2x6)
 [19 26 33] (3x1 + 4x4) (3x2 + 4x5) (3x3 + 4x6)   
 [29 40 51]] (5x1 + 6x4) (5x2 + 6x5) (5x3 + 6x6)
"""

# Array(3차원 배열 이상) 2면 3행 4열
K = np.array([[[1,2,3,4],[5,6,7,8],[9,10,11,12]],[[13,14,15,16],[17,18,19,20],[21,22,23,24]]])
print(K .shape) # (2, 3, 4) - 2면 3행 4열
print(K )
"""
[[[ 1  2  3  4]
  [ 5  6  7  8]
  [ 9 10 11 12]]

 [[13 14 15 16]
  [17 18 19 20]
  [21 22 23 24]]]
"""
print(np.ndim(K )) # 3 (차원)

# 교환 법칙 성립 X
Y = np.dot(A,B) # 3x2 - 2x3 = 3x3
Z = np.dot(B,A) # 2x3 - 3x2 = 2x2

print(Y)
"""
[[ 9 12 15]
 [19 26 33]
 [29 40 51]]
"""

print(Z) # 2행 2열

"""
[[22 28]
 [49 64]]
 """

# A가 2차원 행렬, B가 1차원 배열 곱
A = np.array([[1,2],[3,4],[5,6]]) # 3행 2열
B = np.array([7,8]) # 1행 2열로 보이지만 내적의 곱을 할 때 2행 1열로 구성된다.
print(B.shape) # (2,) 열,
print(A.shape) # (3, 2) 행, 열

print(np.dot(A,B)) # [23 53 83] 1행 3열 처럼 출력.

# 신경망의 내적
X = np.array([1,2]) # x1 = 1, x2 = 2
W = np.array([[1,3,5],[2,4,6]])
Y = np.dot(X,W) # 1행 2열 x 2행 3열
# Y = X * W + B
print(Y) #[ 5 11 17] (1x1+ 2x2) (1x3 + 2x4) (1x5 + 2x6)




















